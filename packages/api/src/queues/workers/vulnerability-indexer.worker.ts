/**
 * Vulnerability Indexer Worker
 * Processes vulnerability scan results and indexes CVEs into the database
 * Supports Grype JSON output format
 */

import { Worker, Job } from 'bullmq';

import { createRedisConnection, QueueName } from '../config';
import { logger } from '../../utils/logger';

/**
 * Job data for vulnerability indexing
 */
export interface VulnerabilityIndexerJobData {
  evidenceId: string;
  tenantId: string;
  projectName: string;
  vulnerabilities: Record<string, unknown>;
  scanner: 'grype' | 'trivy' | 'other';
}

/**
 * Parsed vulnerability information
 */
interface ParsedVulnerability {
  cveId: string;
  severity: 'Critical' | 'High' | 'Medium' | 'Low' | 'Negligible' | 'Unknown';
  packageName: string;
  packageVersion: string;
  fixedVersion?: string;
  description?: string;
  urls?: string[];
  cvssScore?: number;
  cvssVector?: string;
}

/**
 * Severity mapping from scanner output to normalized values
 */
function normalizeSeverity(severity: string): ParsedVulnerability['severity'] {
  const severityMap: Record<
    string,
    ParsedVulnerability['severity']
  > = {
    critical: 'Critical',
    high: 'High',
    medium: 'Medium',
    low: 'Low',
    negligible: 'Negligible',
    unknown: 'Unknown',
  };

  return severityMap[severity.toLowerCase()] ?? 'Unknown';
}

/**
 * Parse Grype vulnerability scan results
 */
function parseGrype(
  vulnerabilities: Record<string, unknown>
): ParsedVulnerability[] {
  const parsed: ParsedVulnerability[] = [];

  if (!Array.isArray(vulnerabilities['matches'])) {
    logger.warn('Grype scan has no matches array');
    return parsed;
  }

  for (const match of vulnerabilities['matches'] as any[]) {
    const vuln = match['vulnerability'];
    const artifact = match['artifact'];
    const relatedVulnerabilities = match['relatedVulnerabilities'] ?? [];

    // Extract CVE ID
    const cveId = vuln['id'] ?? 'UNKNOWN';

    // Extract severity
    const severity = normalizeSeverity(vuln['severity'] ?? 'Unknown');

    // Extract package info
    const packageName = artifact['name'] ?? 'unknown';
    const packageVersion = artifact['version'] ?? 'unknown';

    // Extract fix version
    const fixedVersion = vuln['fix']?.['versions']?.[0] ?? undefined;

    // Extract CVSS information
    let cvssScore: number | undefined;
    let cvssVector: string | undefined;

    if (Array.isArray(vuln['cvss'])) {
      const cvssEntry = vuln['cvss'][0];
      if (cvssEntry) {
        if (cvssEntry['metrics']) {
          cvssScore = cvssEntry['metrics']['baseScore'];
        }
        cvssVector = cvssEntry['vector'];
      }
    }

    // Extract URLs
    const urls: string[] = [];
    if (typeof vuln['dataSource'] === 'string') {
      urls.push(vuln['dataSource']);
    }
    if (Array.isArray(relatedVulnerabilities)) {
      for (const related of relatedVulnerabilities) {
        if (typeof related['dataSource'] === 'string') {
          urls.push(related['dataSource']);
        }
      }
    }

    parsed.push({
      cveId,
      severity,
      packageName,
      packageVersion,
      fixedVersion,
      description: vuln['description'],
      urls: urls.length > 0 ? urls : undefined,
      cvssScore,
      cvssVector,
    });
  }

  return parsed;
}

/**
 * Process vulnerability indexing job
 */
async function processVulnerabilityIndexer(
  job: Job<VulnerabilityIndexerJobData>
): Promise<void> {
  const { evidenceId, tenantId, projectName, vulnerabilities, scanner } =
    job.data;

  logger.info('Processing vulnerability indexer job', {
    jobId: job.id,
    evidenceId,
    tenantId,
    projectName,
    scanner,
  });

  try {
    // Parse vulnerabilities based on scanner
    let parsed: ParsedVulnerability[];
    if (scanner === 'grype') {
      parsed = parseGrype(vulnerabilities);
    } else if (scanner === 'trivy') {
      // TODO: Implement Trivy parser
      throw new Error('Trivy scanner not yet supported');
    } else {
      throw new Error(`Unsupported scanner: ${scanner}`);
    }

    // Count by severity
    const severityCounts = {
      Critical: 0,
      High: 0,
      Medium: 0,
      Low: 0,
      Negligible: 0,
      Unknown: 0,
    };

    for (const vuln of parsed) {
      severityCounts[vuln.severity]++;
    }

    logger.info('Vulnerability scan analysis complete', {
      evidenceId,
      totalVulnerabilities: parsed.length,
      critical: severityCounts.Critical,
      high: severityCounts.High,
      medium: severityCounts.Medium,
      low: severityCounts.Low,
    });

    // TODO: Store vulnerabilities in database
    // This would involve creating a Vulnerability entity and repository
    // For now, we just log the results

    await job.updateProgress(100);

    logger.info('Vulnerability indexing completed successfully', {
      jobId: job.id,
      evidenceId,
      vulnerabilityCount: parsed.length,
    });
  } catch (error) {
    logger.error('Vulnerability indexing failed', {
      jobId: job.id,
      evidenceId,
      error,
    });
    throw error;
  }
}

/**
 * Create and start vulnerability indexer worker
 */
export function createVulnerabilityIndexerWorker(): Worker<VulnerabilityIndexerJobData> {
  const worker = new Worker<VulnerabilityIndexerJobData>(
    QueueName.VULNERABILITY_INDEXER,
    processVulnerabilityIndexer,
    {
      connection: createRedisConnection(),
      concurrency: 5, // Process up to 5 scans concurrently
    }
  );

  worker.on('completed', (job) => {
    logger.info('Vulnerability indexer job completed', {
      jobId: job.id,
      evidenceId: job.data.evidenceId,
    });
  });

  worker.on('failed', (job, error) => {
    logger.error('Vulnerability indexer job failed', {
      jobId: job?.id,
      evidenceId: job?.data.evidenceId,
      error,
    });
  });

  worker.on('error', (error) => {
    logger.error('Vulnerability indexer worker error', { error });
  });

  logger.info('Vulnerability indexer worker started');

  return worker;
}
