/**
 * Vulnerability Indexer Worker
 * Processes vulnerability scan results and indexes CVEs into the database
 * Supports Grype JSON output format
 */

import { Worker, Job } from 'bullmq';

import { AppDataSource } from '@aegis/db/src/data-source';
import { VulnerabilityEntity } from '@aegis/db/src/entities';
import { VulnerabilitySeverity } from '@aegis/shared';
import { logger } from '../../utils/logger';
import { createRedisConnection, QueueName } from '../config';

/**
 * Job data for vulnerability indexing
 */
export interface VulnerabilityIndexerJobData {
  evidenceId: string;
  tenantId: string;
  projectName: string;
  vulnerabilities: Record<string, unknown>;
  scanner: 'grype' | 'trivy' | 'other';
}

/**
 * Parsed vulnerability information
 */
interface ParsedVulnerability {
  cveId: string;
  severity: VulnerabilitySeverity;
  packageName: string;
  packageVersion: string;
  fixedVersion?: string;
  description?: string;
  urls?: string[];
  cvssScore?: number;
  cvssVector?: string;
  publishedDate?: Date;
  modifiedDate?: Date;
}

/**
 * Severity mapping from scanner output to normalized values
 */
function normalizeSeverity(severity: string): VulnerabilitySeverity {
  const severityMap: Record<string, VulnerabilitySeverity> = {
    critical: VulnerabilitySeverity.CRITICAL,
    high: VulnerabilitySeverity.HIGH,
    medium: VulnerabilitySeverity.MEDIUM,
    low: VulnerabilitySeverity.LOW,
    negligible: VulnerabilitySeverity.NEGLIGIBLE,
    unknown: VulnerabilitySeverity.UNKNOWN,
  };

  return severityMap[severity.toLowerCase()] ?? VulnerabilitySeverity.UNKNOWN;
}

/**
 * Parse Grype vulnerability scan results
 */
function parseGrype(
  vulnerabilities: Record<string, unknown>
): ParsedVulnerability[] {
  const parsed: ParsedVulnerability[] = [];

  if (!Array.isArray(vulnerabilities['matches'])) {
    logger.warn('Grype scan has no matches array');
    return parsed;
  }

  for (const match of vulnerabilities['matches']) {
    const vuln = match['vulnerability'];
    const artifact = match['artifact'];
    const relatedVulnerabilities = match['relatedVulnerabilities'] ?? [];

    // Extract CVE ID
    const cveId = vuln['id'] ?? 'UNKNOWN';

    // Extract severity
    const severity = normalizeSeverity(vuln['severity'] ?? 'Unknown');

    // Extract package info
    const packageName = artifact['name'] ?? 'unknown';
    const packageVersion = artifact['version'] ?? 'unknown';

    // Extract fix version
    const fixedVersion = vuln['fix']?.['versions']?.[0] ?? undefined;

    // Extract CVSS information
    let cvssScore: number | undefined;
    let cvssVector: string | undefined;

    if (Array.isArray(vuln['cvss'])) {
      const cvssEntry = vuln['cvss'][0];
      if (cvssEntry) {
        if (cvssEntry['metrics']) {
          cvssScore = cvssEntry['metrics']['baseScore'];
        }
        cvssVector = cvssEntry['vector'];
      }
    }

    // Extract URLs
    const urls: string[] = [];
    if (typeof vuln['dataSource'] === 'string') {
      urls.push(vuln['dataSource']);
    }
    if (Array.isArray(relatedVulnerabilities)) {
      for (const related of relatedVulnerabilities) {
        if (typeof related['dataSource'] === 'string') {
          urls.push(related['dataSource']);
        }
      }
    }

    parsed.push({
      cveId,
      severity,
      packageName,
      packageVersion,
      fixedVersion,
      description: vuln['description'],
      urls: urls.length > 0 ? urls : undefined,
      cvssScore,
      cvssVector,
    });
  }

  return parsed;
}

/**
 * Process vulnerability indexing job
 */
async function processVulnerabilityIndexer(
  job: Job<VulnerabilityIndexerJobData>
): Promise<void> {
  const { evidenceId, tenantId, projectName, vulnerabilities, scanner } =
    job.data;

  logger.info('Processing vulnerability indexer job', {
    jobId: job.id,
    evidenceId,
    tenantId,
    projectName,
    scanner,
  });

  try {
    // Parse vulnerabilities based on scanner
    let parsed: ParsedVulnerability[];
    if (scanner === 'grype') {
      parsed = parseGrype(vulnerabilities);
    } else if (scanner === 'trivy') {
      // TODO: Implement Trivy parser
      throw new Error('Trivy scanner not yet supported');
    } else {
      throw new Error(`Unsupported scanner: ${scanner}`);
    }

    // Count by severity
    const severityCounts: Record<VulnerabilitySeverity, number> = {
      [VulnerabilitySeverity.CRITICAL]: 0,
      [VulnerabilitySeverity.HIGH]: 0,
      [VulnerabilitySeverity.MEDIUM]: 0,
      [VulnerabilitySeverity.LOW]: 0,
      [VulnerabilitySeverity.NEGLIGIBLE]: 0,
      [VulnerabilitySeverity.UNKNOWN]: 0,
    };

    for (const vuln of parsed) {
      severityCounts[vuln.severity]++;
    }

    logger.info('Vulnerability scan analysis complete', {
      evidenceId,
      totalVulnerabilities: parsed.length,
      critical: severityCounts[VulnerabilitySeverity.CRITICAL],
      high: severityCounts[VulnerabilitySeverity.HIGH],
      medium: severityCounts[VulnerabilitySeverity.MEDIUM],
      low: severityCounts[VulnerabilitySeverity.LOW],
    });

    // Store vulnerabilities in database
    if (parsed.length > 0) {
      const vulnRepo = AppDataSource.getRepository(VulnerabilityEntity);

      // Prepare vulnerability entities for batch insert
      const vulnEntities = parsed.map((vuln) => ({
        evidenceId,
        cveId: vuln.cveId,
        severity: vuln.severity,
        cvssScore: vuln.cvssScore,
        cvssVector: vuln.cvssVector,
        packageName: vuln.packageName,
        packageVersion: vuln.packageVersion,
        fixedVersion: vuln.fixedVersion,
        description: vuln.description || `Vulnerability ${vuln.cveId} in ${vuln.packageName}`,
        references: vuln.urls || [],
        publishedDate: vuln.publishedDate,
        modifiedDate: vuln.modifiedDate,
      }));

      // Batch insert all vulnerabilities for performance
      await vulnRepo
        .createQueryBuilder()
        .insert()
        .into(VulnerabilityEntity)
        .values(vulnEntities)
        .execute();

      logger.info(`Stored ${parsed.length} vulnerabilities in database`, {
        evidenceId,
      });
    }

    await job.updateProgress(100);

    logger.info('Vulnerability indexing completed successfully', {
      jobId: job.id,
      evidenceId,
      vulnerabilityCount: parsed.length,
    });
  } catch (error) {
    logger.error('Vulnerability indexing failed', {
      jobId: job.id,
      evidenceId,
      error,
    });
    throw error;
  }
}

/**
 * Create and start vulnerability indexer worker
 */
export function createVulnerabilityIndexerWorker(): Worker<VulnerabilityIndexerJobData> {
  const worker = new Worker<VulnerabilityIndexerJobData>(
    QueueName.VULNERABILITY_INDEXER,
    processVulnerabilityIndexer,
    {
      connection: createRedisConnection(),
      concurrency: 5, // Process up to 5 scans concurrently
    }
  );

  worker.on('completed', (job) => {
    logger.info('Vulnerability indexer job completed', {
      jobId: job.id,
      evidenceId: job.data.evidenceId,
    });
  });

  worker.on('failed', (job, error) => {
    logger.error('Vulnerability indexer job failed', {
      jobId: job?.id,
      evidenceId: job?.data.evidenceId,
      error,
    });
  });

  worker.on('error', (error) => {
    logger.error('Vulnerability indexer worker error', { error });
  });

  logger.info('Vulnerability indexer worker started');

  return worker;
}
